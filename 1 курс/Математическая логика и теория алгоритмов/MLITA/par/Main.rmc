unit Main // Объявление модуля. unit - ключевое слово, Main - название.
                
    entry main // Объявление точки входа.
    {   
        Z(5)
        Z(25)
        Z(26)
        Z(27)
        Z(29)
        I(0) // Чтение числа в регистр 0
        J(0, 99, 20) // Если ввели 0, на выход
        J(5, 30, 19) // Если значение k и верхний предел суммы равны
        Z(102)
        Z(103)
        Z(104)
        Z(105)
        s(mt1, 100) // Запуск программы test1 в параллельном процессе и сопоставление с ней регистра-индикатора с номером 100
        s(div, 104)
        J(99, 104, 15) // Если программа деления не закончилась, никуда не идем
        s(sum, 105)
        J(99, 105, 17) // Если программа суммирования не закончилась, никуда не идем
        J(1, 1, 8)
        s(fin, 106)
    }
    // Умножение 2*k+1            
    program mt1
    {   
        Z(2)
        Z(3)
        Z(4)
        J(1, 3, 12) // Если промежуточное значение множителя равно самому множителю
        J(5, 2, 9) // Если промежуточное значение числа и значение x равны
        S(2)
        S(4)
        J(1, 1, 5)
        S(3) // Увеличение промежуточного значения множителя
        Z(2) // Очистка промежуточного значения Числа
        J(1, 1, 4)
        S(4)
        s(st1, 102)
        s(fact, 103)
        
    }
    // Возведение в степень 100*x^[2k+1]
    program st1
    {
        Z(8)
        S(8)
        J(4, 8, 20) // Если степень равна 1
        T(0, 9)
        J(4, 8, 21) // Если промежуточное значение степени равно исходной степени
        Z(6)
        Z(7)
        Z(10)
        J(0, 6, 17) // Если промежуточное значение множителя равно самому множителю
        J(7, 9, 14) // Если промежуточное значение числа равно множимому числу
        S(7)
        S(10)
        J(1, 1, 10)
        S(6) // Увеличение промежуточного значения множителя
        Z(7)
        J(1, 1, 9)
        S(8) // Увеличение промежуточного значения степени
        T(10, 9)
        J(1, 1, 5)
        T(0, 10)
        // умножение на 100
        Z(19)
        S(19)
        T(10, 21)
        J(19, 20, 32) // Если вспомогательное значение для умножения на 100 равно 100, то завершаем работу
        Z(18)
        J(18, 21, 30)
        S(10)
        S(18)
        J(1, 1, 26)
        S(19)
        J(1, 1, 24)
    }
    
    //Факториал [2k+1]!
    program fact
    {
        T(4, 13)
        Z(17)
        S(17) //{1}
        J(4, 17, 30) // Если значение Рг4 равно 1, увеличить 16 на 1 (можно вывести в результат 1!!!)
        S(15)
        S(17)
        J(4, 17, 9)
        J(1, 1, 5) // Если Рг4 и Рг17 не равны, продолжать увеличивать
        // Умножаем
        Z(11)
        Z(14)
        Z(12)
        S(12)
        S(14)
        J(12, 13, 16) //Если промежуочное значение числа равно самому числу
        J(1, 1, 12)
        S(11)
        J(11, 15, 19) // Если промежуточное значение множителя равно самому множителю
        J(1, 1, 11)
        T(15, 16)
        Z(15)
        Z(17)
        S(17)// {1}
        J(16, 17, 32) // Если множитель равен 1, вывести ответ
        S(15)
        S(17)
        J(16, 17, 28)
        J(1, 1, 24) // Если Рг16 и Рг17 не равны, продолжать увеличивать
        T(14, 13) // Копируем предыдущий результат умножения в регистр с копией числа
        J(1, 1, 9)
        Z(14)
        S(14)
    }
    
    // Деление 100*x^[2k+1]/[2k+1]!
    program div
    {   
        J(99, 102, 1) // Завершилось ли вычисление 100*x^[2k+1] 
        J(99, 103, 2) // Завершилось ли вычисление [2k+1]!
        Z(22)
        Z(23)
        Z(24)
        S(22) // Увеличение промежуточного значения числа А
        S(23) // Увеличение промежуточного значения числа B
        J(14, 23, 11) // Равно ли число B промежуточному значению
        J(10, 22, 14) // Равно ли число А промежуточному значению
        J(1, 1, 6)
        S(24) // +1 в ответ
        Z(23)
        J(1, 1, 8)
        Z(22)
        Z(23)
    }
    
    //Суммирование
    program sum
    {   
        Z(98)
        S(98)
        J(25, 98, 9) // (k = 1?) Если k нечетное, прибавляем к "разности", иначе к "сумме"
        // прибавляем к "сумме"
        Z(28) // очищаем значение промежуточной суммы
        J(24, 28, 16) // если промежуточная сумма и прибавляемая сумма равны, идем увел. k 
        S(26)
        S(28)
        J(1, 1, 5)
        // Прибавляем к разности
        Z(28) // очищаем значение промежуточной суммы
        J(24, 28, 14) // если промежуточная сумма и прибавляемая сумма равны, идем увел. k 
        S(27)
        S(28)
        J(1, 1, 10)
        Z(25)
        J(1, 1, 17)
        S(25)
        S(5) //k+1
    }
    
    // разность сумм +100
    program fin
    {
        J(26, 27, 5)
        S(27)
        S(29)
        J(1, 1, 1)
        Z(31)
        J(31, 20, 10)
        S(29)
        S(31)
        J(1, 1, 6)
        T(29, 0)
    }


